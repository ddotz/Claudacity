#!/usr/bin/expect -f
# ============================================================================
# claude-usage.exp - Claude CLI 사용량 조회 스크립트 (Interactive Mode)
# ============================================================================

set timeout 30
log_user 0

# Debug log file
set debug_log "/tmp/claudacity-expect-debug.log"
set log_fd [open $debug_log "w"]
puts $log_fd "=== Claude Usage Expect Script Debug Log ==="
puts $log_fd "Started at: [clock format [clock seconds]]"
flush $log_fd

# Determine Claude CLI path
set claude_cli "claude"
if {[llength $argv] > 0} {
    set claude_cli [lindex $argv 0]
} elseif {[info exists env(CLAUDE_USAGE_CLI_PATH)] && $env(CLAUDE_USAGE_CLI_PATH) ne ""} {
    set claude_cli $env(CLAUDE_USAGE_CLI_PATH)
}

# Spawn Claude CLI in interactive mode with /usage command
set cmd "$claude_cli /usage"
puts $log_fd "Executing command: $cmd"
flush $log_fd

if {[catch {spawn /bin/sh -c $cmd} err]} {
    puts $log_fd "ERROR: Failed to spawn: $err"
    puts "ERROR:spawn:$err"
    close $log_fd
    exit 127
}

puts $log_fd "Process spawned successfully"
flush $log_fd

# Accumulate output
set full_output ""
set usage_data_found 0

# Wait for output and collect it
expect {
    -re {.+} {
        append full_output $expect_out(0,string)

        # Check if we have at least 2 "% used" patterns (session + weekly)
        set pct_count [regexp -all -nocase {\d+%\s*used} $full_output]

        if {$pct_count >= 1 && !$usage_data_found} {
            puts $log_fd "Usage data detected in output"
            flush $log_fd
            set usage_data_found 1
        }

        if {$usage_data_found} {
            puts $log_fd "Found $pct_count percentage patterns"
            flush $log_fd
        }

        if {$pct_count >= 2} {
            # Got both session and weekly, wait a bit more for completion
            puts $log_fd "Found both session and weekly data, exiting..."
            flush $log_fd
            sleep 1
            # Exit the expect loop
        } else {
            # Keep reading
            exp_continue
        }
    }
    timeout {
        # Timeout reached, process whatever we have
        puts $log_fd "TIMEOUT: Reached after 30 seconds"
        flush $log_fd
    }
    eof {
        # Process ended naturally
        puts $log_fd "EOF: Process ended"
        flush $log_fd
    }
}

puts $log_fd "Expect loop finished"
flush $log_fd

# Try to exit gracefully
catch {
    send "\x1b"
    sleep 0.1
    send "\x03"
}
catch {close}
catch {wait}

puts $log_fd "Process closed"
flush $log_fd

# Strip ANSI escape sequences before parsing
regsub -all {\x1b\[[0-9;:?]*[@-~]} $full_output "" clean_output
regsub -all {\x1b\][^\x07]*\x07} $clean_output "" clean_output
regsub -all {\x1b[()][AB012]} $clean_output "" clean_output
regsub -all {[\x00-\x09\x0b-\x1f]} $clean_output "" clean_output

# ============================================================================
# PARSING RULES
# ============================================================================
#
# CLI OUTPUT FORMAT:
# ------------------
# Current session
# ████████████████████               37% used
# Resets 2:59am (Asia/Seoul)
#
# Current week (all models)
# ████████                           15% used
# Resets Jan 1, 2026, 4:59pm (Asia/Seoul)
#
# PARSING STRATEGY:
# -----------------
# - Find all "XX% used" patterns in order: 1st = session, 2nd = weekly
# - Find reset times after each percentage
# - Session reset = time only, Weekly reset = date + time
#
# ============================================================================

set session_pct ""
set weekly_pct ""
set session_reset ""
set weekly_reset ""

# --- PERCENTAGE PARSING ---
# Find all "XX% used" patterns in order
set pct_matches [regexp -all -inline -nocase {(\d+)%\s*used} $clean_output]
if {[llength $pct_matches] >= 2} {
    set session_pct [lindex $pct_matches 1]
}
if {[llength $pct_matches] >= 4} {
    set weekly_pct [lindex $pct_matches 3]
}

# --- RESET TIME PARSING ---
# Time pattern: "H:MMam/pm (Timezone)" or "Hpm (Timezone)"
set time_pattern {(\d{1,2}(?::\d{2})?[aApP][mM])\s*\(([^)]+)\)}

# Date+time pattern for weekly: "Mon DD, YYYY, H:MMam/pm (Timezone)"
set date_time_pattern {((?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep(?:t|tember)?|Oct|Nov|Dec)\s+\d{1,2},?\s+(?:\d{4},?\s+)?\d{1,2}(?::\d{2})?[aApP][mM])\s*\(([^)]+)\)}

# Find all time patterns
set all_times [regexp -all -inline -nocase $time_pattern $clean_output]

# 1st time = SESSION reset
if {[llength $all_times] >= 3} {
    set session_time [lindex $all_times 1]
    set session_tz [lindex $all_times 2]
    set session_reset "$session_time ($session_tz)"
}

# 2nd time = WEEKLY reset (try date+time pattern first)
set weekly_found 0
if {[regexp -nocase {Current\s*week\s*\(all[^)]*\)(.+)} $clean_output - weekly_section]} {
    if {[regexp -nocase $date_time_pattern $weekly_section - dt_match tz_match]} {
        # Remove year from date string (e.g., "Jan 1, 2026, 5pm" -> "Jan 1, 5pm")
        set dt_clean $dt_match
        regsub -nocase {,?\s*\d{4},?\s*} $dt_clean ", " dt_clean
        set weekly_reset "$dt_clean ($tz_match)"
        set weekly_found 1
    }
}

# Fallback: use 2nd simple time pattern
if {!$weekly_found && [llength $all_times] >= 6} {
    set weekly_time [lindex $all_times 4]
    set weekly_tz [lindex $all_times 5]
    set weekly_reset "$weekly_time ($weekly_tz)"
}

# Output results
puts $log_fd "=== Parsing Results ==="
puts $log_fd "Session %: $session_pct"
puts $log_fd "Session Reset: $session_reset"
puts $log_fd "Weekly %: $weekly_pct"
puts $log_fd "Weekly Reset: $weekly_reset"
puts $log_fd "=== End Results ==="
flush $log_fd

if {$session_pct ne ""} {
    puts "SESSION_USED:$session_pct"
    puts $log_fd "OUTPUT: SESSION_USED:$session_pct"
}
if {$session_reset ne ""} {
    puts "SESSION_RESET:$session_reset"
    puts $log_fd "OUTPUT: SESSION_RESET:$session_reset"
}
if {$weekly_pct ne ""} {
    puts "WEEKLY_USED:$weekly_pct"
    puts $log_fd "OUTPUT: WEEKLY_USED:$weekly_pct"
}
if {$weekly_reset ne ""} {
    puts "WEEKLY_RESET:$weekly_reset"
    puts $log_fd "OUTPUT: WEEKLY_RESET:$weekly_reset"
}

if {$session_pct eq ""} {
    puts "ERROR:parse_failed"
    puts $log_fd "ERROR: Parse failed - no session percentage found"
    close $log_fd
    exit 1
}

puts $log_fd "Script completed successfully at: [clock format [clock seconds]]"
close $log_fd
exit 0
